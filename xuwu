#!/bin/bash

# 定义颜色常量
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # 恢复默认颜色

TARGET_EXT="uexp"
LITTLE_ENDIAN=1  # 1=小端，0=大端
TMP_DIR="/storage/emulated/0/虚无梅花工具/临时"  

# 整数转十六进制（带字节序处理）
function int_to_hex_le() {
    local integer=$1
    local hex=$(printf "%08X" "$integer")
    if [ $LITTLE_ENDIAN -eq 1 ]; then
        hex=$(echo "$hex" | awk '{for(i=length;i>0;i-=2) printf substr($0,i-1,2)}')
    fi
    echo "$hex"
}

function show_menu() {
    clear
    echo -e "${BLUE}====================================================${NC}"
    echo -e "${BLUE}||     虚无全自动衣服梅花      ||${NC}"
    echo -e "${BLUE}====================================================${NC}"
    echo -e "${GREEN}1.${NC} 16进制批量修改uexp"
    echo -e "${YELLOW}2.${NC} 完全卸载此程序"
    echo -e "${YELLOW}3.${NC} 暂时无（预留）"
    echo -e "${RED}0.${NC} 退出"
    echo -e "${BLUE}====================================================${NC}"
    echo -n -e "${GREEN}请输入选项编号（0-3）：${NC}"
}

function verify_hex_modification() {
    local source_file="$1"
    local target_file="$2"
    local old_hex_list="$3"  # 用空格分隔的旧十六进制列表
    local new_hex_list="$4"  # 用空格分隔的新十六进制列表

    # 一次性读取文件内容，避免重复打开
    local source_hex=$(xxd -p "$source_file" | tr 'a-f' 'A-F')
    local target_hex=$(xxd -p "$target_file" | tr 'a-f' 'A-F')

    # 校验所有规则是否替换成功
    local old_hex_arr=($old_hex_list)
    local new_hex_arr=($new_hex_list)
    for ((i=0; i<${#old_hex_arr[@]}; i++)); do
        local old_hex=${old_hex_arr[$i]}
        local new_hex=${new_hex_arr[$i]}
        # 原文件有旧值，且目标文件无旧值、有新值 → 校验通过
        if [[ "$source_hex" == *"$old_hex"* ]] && [[ "$target_hex" != *"$old_hex"* ]] && [[ "$target_hex" == *"$new_hex"* ]]; then
            return 0
        fi
    done
    # 原文件无任何匹配规则 → 也视为通过
    for old_hex in ${old_hex_arr[@]}; do
        if [[ "$source_hex" == *"$old_hex"* ]]; then
            return 1  # 有未替换的规则
        fi
    done
    return 0
}

function hex_batch_modify_uexp() {
    clear
    echo -e "${BLUE}====================================================${NC}"
    echo -e "${BLUE}||     16进制批量修改uexp（支持整数+大小端）      ||${NC}"
    echo -e "${BLUE}====================================================${NC}"
    
    WORK_DIR="/storage/emulated/0/虚无梅花工具"
    HEX_RULES_FILE="$WORK_DIR/16进制替换规则.txt"
    OUTPUT_DIR="$WORK_DIR/修改后文件"
    
    # 自动创建目录（一次性创建，避免重复判断）
    mkdir -p "$TMP_DIR" "$WORK_DIR" "$OUTPUT_DIR" || {
        echo -e "${RED}错误：无法创建目录，请检查权限${NC}"
        read -p "按回车键继续..."
        return
    }

    # 检查xxd工具（提前检查，避免后续重复判断）
    if ! command -v xxd &> /dev/null; then
        echo -e "${RED}错误：未找到xxd工具，请执行 pkg install xxd${NC}"
        read -p "按回车键继续..."
        return
    fi

    # 生成规则文件（若不存在）
    if [ ! -f "$HEX_RULES_FILE" ]; then
        echo -e "${YELLOW}生成规则文件模板：$HEX_RULES_FILE${NC}"
        cat > "$HEX_RULES_FILE" << EOF
# 格式：每行一个替换规则，左侧原始整数，右侧替换整数
# 示例：423100 123456
EOF
        echo -e "${RED}请填写规则后重新运行${NC}"
        read -p "按回车键继续..."
        return
    fi

    # 加载替换规则（一次性解析，生成替换列表）
    echo -e "${GREEN}加载替换规则...${NC}"
    local OLD_HEX_LIST=""  # 用空格分隔所有旧十六进制
    local NEW_HEX_LIST=""  # 用空格分隔所有新十六进制
    local RULES_VALID=1

    while IFS= read -r line; do
        [[ -z "$line" || "$line" =~ ^# ]] && continue
        
        ORIGINAL_INT=$(echo "$line" | awk '{print $1}')
        REPLACEMENT_INT=$(echo "$line" | awk '{print $2}')
        
        if [ -z "$ORIGINAL_INT" ] || [ -z "$REPLACEMENT_INT" ]; then
            echo -e "${RED}无效规则：缺少整数 - $line${NC}"
            RULES_VALID=0
            continue
        fi
        if ! [[ "$ORIGINAL_INT" =~ ^[0-9]+$ ]] || ! [[ "$REPLACEMENT_INT" =~ ^[0-9]+$ ]]; then
            echo -e "${RED}无效规则：非整数 - $line${NC}"
            RULES_VALID=0
            continue
        fi

        ORIGINAL_HEX=$(int_to_hex_le "$ORIGINAL_INT")
        REPLACEMENT_HEX=$(int_to_hex_le "$REPLACEMENT_INT")
        echo -e "  $ORIGINAL_INT → $REPLACEMENT_INT（$ORIGINAL_HEX → $REPLACEMENT_HEX）"

        if [ $(( ${#ORIGINAL_HEX} % 2 )) -ne 0 ] || [ $(( ${#REPLACEMENT_HEX} % 2 )) -ne 0 ]; then
            echo -e "${RED}无效规则：十六进制长度为奇数${NC}"
            RULES_VALID=0
        elif [ ${#ORIGINAL_HEX} -ne ${#REPLACEMENT_HEX} ]; then
            echo -e "${RED}无效规则：长度不匹配${NC}"
            RULES_VALID=0
        else
            OLD_HEX_LIST+=" $ORIGINAL_HEX"  # 累加旧值列表
            NEW_HEX_LIST+=" $REPLACEMENT_HEX"  # 累加新值列表
        fi
    done < "$HEX_RULES_FILE"

    if [ $RULES_VALID -eq 0 ] || [ -z "$OLD_HEX_LIST" ]; then
        echo -e "${RED}规则无效，请修正${NC}"
        read -p "按回车键继续..."
        return
    fi

    # 扫描目标文件（一次性获取所有文件）
    echo -e "\n${GREEN}扫描文件...${NC}"
    local FILE_LIST=$(find "$WORK_DIR" -maxdepth 1 -type f ! -name "$(basename "$HEX_RULES_FILE")" -name "*.${TARGET_EXT}" 2>/dev/null)
    if [ -z "$FILE_LIST" ]; then
        echo -e "${YELLOW}未找到.uexp文件，请放入$WORK_DIR${NC}"
        read -p "按回车键继续..."
        return
    fi

    # 显示待处理文件
    echo -e "\n${BLUE}待处理文件：${NC}"
    echo -e "${BLUE}--------------------------------------------------------${NC}"
    local FILE_ARR=()
    while IFS= read -r file; do
        FILE_ARR+=("$file")
        echo -e "- $(basename "$file")"
    done <<< "$FILE_LIST"
    local TOTAL_FILES=${#FILE_ARR[@]}
    echo -e "${BLUE}--------------------------------------------------------${NC}"
    echo -e "共 ${GREEN}$TOTAL_FILES${NC} 个文件，输出到：${GREEN}$OUTPUT_DIR${NC}"

    read -p "确认修改？(y/n) " CONFIRM
    if [ "$CONFIRM" != "y" ] && [ "$CONFIRM" != "Y" ]; then
        echo -e "${YELLOW}已取消${NC}"
        read -p "按回车键继续..."
        return
    fi

    # 批量修改（核心提速部分）
    echo -e "\n${GREEN}开始修改...${NC}"
    local SUCCESS_COUNT=0
    local VERIFY_FAIL_COUNT=0

    for file in "${FILE_ARR[@]}"; do
        local filename=$(basename "$file")
        local output_file="$OUTPUT_DIR/$filename"
        local tmp_hex="$TMP_DIR/${filename}_temp.hex"

        echo -e "\n处理：${YELLOW}$filename${NC}"

        # 一次性读取文件并转换为十六进制（避免重复调用xxd）
        local file_hex=$(xxd -p "$file" | tr 'a-f' 'A-F')

        # 检查是否需要修改（用grep一次性匹配所有旧值）
        local need_modify=0
        for old_hex in $OLD_HEX_LIST; do
            if [[ "$file_hex" == *"$old_hex"* ]]; then
                need_modify=1
                break
            fi
        done

        if [ $need_modify -eq 0 ]; then
            echo -e "  ${YELLOW}无匹配规则，直接复制${NC}"
            cp "$file" "$output_file" && SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
            continue
        fi

        # 写入临时文件并批量替换（合并所有替换操作）
        echo -n "$file_hex" > "$tmp_hex"  # 直接写入变量内容，避免再次调用xxd
        for ((i=0; i<${#OLD_HEX_LIST[@]}; i++)); do
            local old_hex=$(echo $OLD_HEX_LIST | cut -d' ' -f$((i+1)))
            local new_hex=$(echo $NEW_HEX_LIST | cut -d' ' -f$((i+1)))
            sed -i "s/$old_hex/$new_hex/g" "$tmp_hex"
        done

        # 转换回二进制文件
        if ! xxd -r -p "$tmp_hex" > "$output_file"; then
            echo -e "  ${RED}写入失败${NC}"
            rm -f "$output_file" "$tmp_hex"
            continue
        fi

        # 校验修改结果（一次性校验所有规则）
        if verify_hex_modification "$file" "$output_file" "$OLD_HEX_LIST" "$NEW_HEX_LIST"; then
            echo -e "  ${GREEN}修改成功${NC}"
            SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
        else
            echo -e "  ${RED}校验失败${NC}"
            rm -f "$output_file"
            VERIFY_FAIL_COUNT=$((VERIFY_FAIL_COUNT + 1))
        fi

        rm -f "$tmp_hex"  # 清理临时文件
    done

    # 输出结果
    echo -e "\n${BLUE}===== 完成 =====${NC}"
    echo -e "总文件：${GREEN}$TOTAL_FILES${NC}"
    echo -e "成功：${GREEN}$SUCCESS_COUNT${NC}"
    echo -e "校验失败：${RED}$VERIFY_FAIL_COUNT${NC}"
    echo -e "读写失败：${RED}$((TOTAL_FILES - SUCCESS_COUNT - VERIFY_FAIL_COUNT))${NC}"
    echo -e "输出目录：${GREEN}$OUTPUT_DIR${NC}"
    read -p "按回车键继续..."
}

while true; do
    show_menu
    read choice
    case $choice in
        1) hex_batch_modify_uexp ;;
        2)
        # 删除目录及其所有内容（强制删除，无需确认）
rm -rf "/storage/emulated/0/虚无梅花工具"
rm -rf "$HOME/xuwumeihua"
echo 再见👋🏻👋🏻
        ;;
        3) echo -e "${YELLOW}功能暂未实现${NC}"; read -p "" ;;
        0) echo -e "${RED}退出${NC}"; exit 0 ;;
        *) echo -e "${RED}无效选项${NC}"; read -p "" ;;
    esac
done
